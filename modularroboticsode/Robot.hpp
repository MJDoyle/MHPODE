#ifndef ROBOT_HPP
#define ROBOT_HPP

#include "Module.hpp"

class Robot
{
	public:

		//Constructor
		Robot(dWorldID& worldID, dSpaceID& robotSpaceID, dSpaceID& obstacleSpaceID, std::vector<Vector3Df> modules, std::vector<Vector3Di> unscaledModules, Vector3Df startingPosition, MatrixNMf startingOrientation, std::shared_ptr<Parameters> parameters);

		//Deconstructor (must remove all ODE bodies etc.)
		~Robot();

		//Draw the robot
		void Draw();

		//Run a control step - updates the controllers
		void ControlStep(Vector3Df targetPosition);

		//Apply the forces to the robot generated by the active thrusters
		void ApplyThrusterForces();

		//Apply the forces to the robot generated by the fluid drag
		void ApplyDrag();

		//Get various robot properties
		Vector3Df GetPosition();
		std::vector<std::weak_ptr<Face>> GetFaces() {return m_faces;}
		dBodyID GetBodyID() {return m_bodyID;}

		//Get the total firing time of the robot thrusters (the sum total of, for each thruster, the number of frames during which it was firing)
		long long GetThrusterFiringCounter() {return m_thrusterFiringCounter;}

		dSpaceID GetRobotSpace() {return m_robotSpaceID;}

		//Calculate the pseudo-inverse matrices for the centralized controller
		void CalculatePseudoInverse();

		//A function for counting the number of collisions (the number of frames during which a collision is taking place)
		void IncrementCollisionCounter() {m_collisionCounter ++;}

		//Get the number of collisions
		long long GetCollisionCounter() {return m_collisionCounter;}

		//Get the axis-aligned bounding box of the robot
		std::vector<float> GetAABB() {return m_AABB;}

private:

		//Parameters
		std::shared_ptr<Parameters> m_parameters;

		//All the modules of the robot
		std::vector<std::shared_ptr<Module>> m_modules;

		//Weak pointers to all the faces of the robot (mainly for drag calculation purposes)
		std::vector<std::weak_ptr<Face>> m_faces;

		//Body ID for ODE
		dBodyID m_bodyID;

		//The ID of the robot space (for use by ODE)
		dSpaceID m_robotSpaceID;
		
		//Creates link between faces on either end of an unbroken line of modules, if communication is being used
		void SetLinkedFaces();

		//Total number of external thrusters
		int m_numExternalThrusters;

		//Counter for pump firing 
		long long m_thrusterFiringCounter;

		//Counter for collisions with obstacles
		long long m_collisionCounter;

		//////////////
		//
		//	CENTRALIZED CONTROLLER
		//
		//////////////

		//Adapted from https://dspace.mit.edu/bitstream/handle/1721.1/67312/Rus_Complete%20SE.pdf?sequence=1&isAllowed=y

		//Pseudoinverse matrices that are dependent only upon thruster position and rotation, and as such are static for a given robot topology
		MatrixNMf m_transPseudoInverse;

		MatrixNMf m_rotPseudoInverse;

		//Map of the modules
		std::map<Vector3Di, std::shared_ptr<Module>> m_moduleMap; //In module coordinates

		//The axis aligned bounding box of the robot
		std::vector<float> m_AABB;
};


#endif